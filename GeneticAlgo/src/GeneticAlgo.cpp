/*
 * File:   main.cpp
 * Author: nika
 *
 * Created on November 12, 2015, 8:04 PM
 */

#include <cstdlib>

using namespace std;

/*
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>
#include <omp.h>
#include <vector>
#include <iostream>
#include <limits.h>
#include <algorithm>
#include "Task.h"
#include "Processor.h"
#define DATA_SIZE 201
#define MAX_RAND 100

vector<Task> taskList;
std::vector<Processor> processors;
vector<Task> taskListNoDup;
vector<Task> taskListAfterPretask;
vector<Processor> selectedProcessors;
vector<int> selectProc;
vector<vector<Task> > quesAfterDup;
long endTimeBeforeDup, endTimeAfterDup;
vector<std::vector<int> > chrmsm(4);

int prf1 = 0;
int prf2 = 0;

void fill_array(int *data) {
	srand(time(NULL));
	int i;
	for (i = 0; i < DATA_SIZE; i++) {
		data[i] = rand() % MAX_RAND;
	}
}

void fill_array(int *data, int SIZE, int max, int min) {
	srand(time(NULL));
	int i;
	for (i = 0; i < SIZE; i++) {
		data[i] = min + (std::rand() % (max - min + 1));
	}
}

bool sortProcsByPfDesc(const Processor &lhs, const Processor &rhs) {
	return lhs.performanceFactor > rhs.performanceFactor;
}
bool sortProcsByIdAsc(const Processor &lhs, const Processor &rhs) {
	return lhs.identity < rhs.identity;
}
bool sortTasksByIDAsc(const Task &lhs, const Task &rhs) {

	return lhs.id < rhs.id;
}

void setPreTasks() {
	{
		unsigned int i;
#pragma omp parallel for private(i)
		for (i = 0; i < processors.size(); i++) {
			vector<int> al = processors[i].getQue();
			for (unsigned int j = 0; j < al.size(); j++) {
				int get = al[j];
				if (get != -999) {
					//System.out.println("Selected Task " + tasget.getId());
					int id = taskList[get].getTId();
					vector<int> pt;
					for (unsigned int k = 0; k < al.size(); k++) {
						int get1 = al[k];

						if (get1 != -999) {
							//                                  System.out.println("Selected Task to compare " + get1.getId());
							if (taskList[get1].getTId() < id) {
								pt.push_back(taskList[get1].getTId());
							} else {
								break;
							}
						} else {
							continue;
						}
					}
					//          System.out.println("Pretask " + pt);
					taskList[get].setPretask(pt);
				}
			}

		}
	}

}

void setPreTasksForQuesAfterDup() {
	{
		unsigned int i;
#pragma omp parallel for private(i)
		for (i = 0; i < quesAfterDup.size(); i++) {
			//quesAfterDup[i];
			for (unsigned int j = 0; j < quesAfterDup[i].size(); j++) {
				Task get = quesAfterDup[i].at(j);
				if (get.getTId() != -999) {
					//System.out.println("Selected Task " + tasget.getId());
					int id = get.getTId();
					vector<int> pt;
					for (unsigned int k = 0; k < quesAfterDup[i].size(); k++) {
						Task get1 = quesAfterDup[i].at(k);

						if (get1.getTId() != -999) {
							//                                  System.out.println("Selected Task to compare " + get1.getId());
							if (get1.getTId() < id) {
								pt.push_back(get1.getTId());
							} else {
								break;
							}
						} else {
							continue;
						}
					}
					//          System.out.println("Pretask " + pt);
					quesAfterDup[i].at(j).setPretask(pt);
				}
			}

		}
	}

}

void pushPreTQintoQueWithDup(unsigned int procID, vector<int> pt,
		vector<vector<Task> > QwD) {
	for (unsigned int var = 0; var < QwD.size(); var++) {
		if (var == procID) {

			for (unsigned int var3 = 0; var3 < pt.size(); var3++) {
				int exist = false;

				for (unsigned int var2 = 0; var2 < QwD[var].size(); var2++) {
					if (pt[var3] == QwD[var].at(var2).getTId()) {
						exist = true;
						break;
					}
				}
				if (!exist) {
					QwD[var].push_back(taskList[pt[var3]]);
				}
			}

		}
	}

}

void pushPreTQintoQueWithDup2(unsigned int procID, vector<int> pt,
		vector<vector<Task> > QwD) {
	cout << "Duplicate Called" << endl;
	for (unsigned int var = 0; var < QwD.size(); var++) {
		if (var == procID) {

			for (unsigned int var3 = 0; var3 < pt.size(); var3++) {
				int exist = false;

				for (unsigned int var2 = 0; var2 < QwD[var].size(); var2++) {
					if (pt[var3] == QwD[var].at(var2).getTId()) {
						exist = true;
						break;
					}
				}
				if (!exist) {
					QwD[var].push_back(taskList[pt[var3]]);
				}
			}

		}
	}

}

Task getTaskFromProcQueAfterDup(int proc, int task) {
	for (unsigned int var = 0; var < quesAfterDup[proc].size(); var++) {
		if (quesAfterDup[proc].at(var).getTId() == task) {
			return quesAfterDup[proc].at(var);

		}

	}
	std::vector<int> deplist2;
	std::vector<int> pretask2;
	Task t = Task(-999, 0, 0, 0, 0, deplist2, pretask2);
	return t;
}

Task getTaskFromProcQueAfterDupMinEndTime(int task, long curEndT) {
	long minEndTime = curEndT;
	long lastEndTime = 0;
	Task minTask, lastTask;
	unsigned int var;
	for (var = 0; var < quesAfterDup.size(); var++) {

		unsigned int var2;
	//	#pragma omp parallel for private(var2,lastTask,lastEndTime) shared (minTask,minEndTime)

		for (var2 = 0; var2 < quesAfterDup[var].size(); var2++) {
			if (quesAfterDup[var].at(var2).getTId() == task) {
				lastTask = quesAfterDup[var].at(var2);
				lastEndTime = quesAfterDup[var].at(var2).getEndtime();

				if (lastEndTime <= minEndTime) {
//#pragma omp critical
					{
						minEndTime = lastEndTime;
						minTask = lastTask;
					} //			cout<<" Found Minimum Time For Task "<<task<<endl;
				}

			}

		}
	}

	return minTask;
}

void updateTimingsinQueWithDup() {

	{

		long Lastst = 0, Lastet = 0;
//		int LastTaskID = 0;
		//bool TimeSet = false;
		//int tc = 0;
		//for (int i = 0; i < 2; i++)
		{
			{
				for (unsigned int var = 0; var < quesAfterDup.size(); var++) {
					for (unsigned int var2 = 0; var2 < quesAfterDup[var].size();
							var2++) {
						vector<int> depl, ptl;
						depl = quesAfterDup[var].at(var2).getDeplist();
						ptl = quesAfterDup[var].at(var2).getPretask();

						int lastDepTaskID = -99;
						int lastPreTaskID = -99;
						if (depl.size() > 0) {
							lastDepTaskID = depl.at(depl.size() - 1);
						}

						if (ptl.size() > 0) {

							lastPreTaskID = ptl.at(ptl.size() - 1);
						}

						long lastETDepTask = 0, lastETPreTask = 0;
						if (lastDepTaskID != -99) {

							lastETDepTask =
									getTaskFromProcQueAfterDupMinEndTime(
											lastDepTaskID,
											taskList[lastDepTaskID].getEndtime()).getEndtime();
						}
						if (lastPreTaskID != -99) {

							for (unsigned int var3 = 0;
									var3 < quesAfterDup[var].size(); var3++) {
								if (quesAfterDup[var].at(var3).getTId()
										== lastPreTaskID) {

									lastETPreTask =
											quesAfterDup[var].at(var3).getEndtime();
									break;
								}

							}

						}
						/*		cout << "LastDepT " << lastDepTaskID << " LastPT "
						 << lastPreTaskID << endl;
						 cout << "max between " << lastETDepTask << " & "
						 << lastETPreTask << " "
						 << std::max(lastETDepTask, lastETPreTask)
						 << endl;
						 */
						Lastst = std::max(lastETDepTask, lastETPreTask) + 1;
						quesAfterDup[var].at(var2).setStarttime(Lastst);
						quesAfterDup[var].at(var2).setExectime(
								((1000
										* ((long) ((quesAfterDup[var].at(var2).getVal()
												/ processors[var].getSpeed())
												* 10000))) / 10000));
						Lastet = Lastst
								+ quesAfterDup[var].at(var2).getExectime();
						quesAfterDup[var].at(var2).setEndtime(Lastet);
						//LastTaskID = quesAfterDup[var].at(var2).getTId();
						//	taskListAfterPretask.push_back(taskList[tc]);
						//	quesAfterDup[tpid].push_back(taskList[tc]);
						sort(quesAfterDup[var].begin(), quesAfterDup[var].end(),
								sortTasksByIDAsc);

						//	tc++;
					}
				}
			}
		}

	}

}

void printQueDup() {

	cout << "list start" << endl;
	{
		for (unsigned int var = 0; var < quesAfterDup.size(); var++) {
			cout << "Proc " << var << endl;

			for (unsigned int var2 = 0; var2 < quesAfterDup[var].size();
					var2++) {
				cout << quesAfterDup[var].at(var2).toString() << endl;
			}
		}

	}
	cout << "list end" << endl;

}

int main(int argc, char *argv[]) {
	int num_procs, num_tasks;
	int taskLength = 0;
	num_procs = atoi(argv[1]);
	num_tasks = atoi(argv[2]);
	int THREADS = atoi(argv[3]);
	int toSelectProc = atoi(argv[4]);
	clock_t begin, end;
	double time_spent;
	begin = clock();
	taskList.reserve(num_tasks);
	processors.reserve(num_procs);

	double maxTimeBefDup = 0;
	double maxTimeAftDup = 0;
	omp_set_num_threads(THREADS);
	//Task *TaskList2= (Task*) malloc(sizeof(Task) * (num_tasks));

	// Set Performance to processors
#pragma omp parallel
	{
#pragma omp sections
		{
#pragma omp section
			{
				int i;
//#pragma omp parallel for private(i) shared (processors,quesAfterDup)
				for (i = 0; i < num_procs; i++) {
					int min = 10;
					int max = 25;
					int rand = min + (std::rand() % (max - min + 1));
					std::vector<int> q;
					std::vector<int> q2;
					std::vector<Task> q3;
					processors.push_back(Processor(i, rand, 0, q, q2));
					quesAfterDup.push_back(q3);
					//cout << "Proc Added " << processors[i].toString() << endl;
				}
			}

			// populate the tasks
#pragma omp section
			{
				int i;
#pragma omp parallel for private(i) shared (taskList) reduction(+:taskLength)
				for (i = 0; i < num_tasks; i++) {
					int min = 15;
					int max = 30;
					int rand = min + (std::rand() % (max - min + 1));
					taskLength += rand;
					std::vector<int> deplist2;
					std::vector<int> pretask2;
					taskList.push_back(
							Task(i, rand, 0, 0, 0, deplist2, pretask2));
				}
			}
		}
	}
	//For Debugging

	cout << "Total Task Length " << taskLength << endl;
	{
		for (unsigned int i = 0; i < processors.size(); i++) {
			float pf = (float) ((float) processors[i].getSpeed()
					/ (float) taskLength);
			processors[i].setPerformancefactor(pf);
			//	cout << "Processors with pf "<< pf<<" And " << processors[i].toString() << endl;
		}

	}

	std::sort(processors.begin(), processors.end(), sortProcsByPfDesc);
	std::sort(taskList.begin(), taskList.end(), sortTasksByIDAsc);

	cout << "After Sorting" << endl;
	{
		for (unsigned int i = 0; i < processors.size(); i++) {

			cout << "Proc " << processors[i].toString() << endl;
		}

	}

	cout << "Select Processor ID (Press s to finish) " << endl;
	{
		//int input;

		/*		for(;;)

		 {
		 //std::getline(cin,input);
		 if((cin >> input) && input < num_procs)
		 break;
		 selectProc.push_back(input);

		 cin.clear();
		 //  cin.ignore(INT_MAX,'\n');
		 }

		 while ((cin >> input) && input < num_procs) {
		 selectProc.push_back(input);

		 cin.clear();

		 }
		 */

		for (int var = 0; var < toSelectProc; ++var) {
			selectProc.push_back(processors[var].getId());
		}
	}
	cin.clear();
	cout << "Selected Processor NO's " << selectProc.size() << endl;

	{
		for (unsigned int var = 0; var < selectProc.size(); var++) {
			cout << selectProc[var] << ", ";
			for (unsigned int var2 = 0; var2 < processors.size(); var2++) {
				if (processors[var2].getId() == selectProc[var]) {
					selectedProcessors.push_back(processors[var2]);

				}
			}

		}

		cout << endl;
	}
	//selectedProcessors.reserve(selectProc.size());
	{
		for (unsigned int var = 0; var < selectedProcessors.size(); var++) {
			//	cout<< selectProc[var]<< ", ";
			cout << selectedProcessors[var].toString();
		}

		cout << endl;
	}

	std::sort(selectedProcessors.begin(), selectedProcessors.end(),
			sortProcsByPfDesc);

	//Generate Deplist for each Task
	{
		unsigned int var;
#pragma omp parallel for private(var)
		for (var = 0; var < taskList.size(); var++) {
			int min = 0;
			int lmax = var;
			int up = min + (std::rand() % (lmax - min + 1));
			for (int var2 = 0; var2 < up; var2++) {
				lmax = lmax - 1;
				int rand2 = min + (std::rand() % (lmax - min + 1));
				bool t = false;
				for (unsigned int var3 = 0; var3 < taskList[var].deplist.size();
						var3++) {
					if (taskList[var].deplist[var3] == rand2) {
						t = true;
						break;
					}
				}
				if (!t) {
					taskList[var].deplist.push_back(rand2);
				}

			}

			sort(taskList[var].deplist.begin(), taskList[var].deplist.end());
		}

	}

	{
		for (unsigned int i1 = 0; i1 < taskList.size(); i1++) {
			cout << taskList[i1].toString();
		}
	}

	//Generate Chromosomes

	{

		unsigned int var;
#pragma omp parallel for private(var)
		for (var = 0; var < 2; var++) {
			int csno = var * 2;

			for (int var2 = 0; var2 < num_tasks; var2++) {
				int min = 0;
				int max = selectedProcessors.size() - 1;
				int pno = min + (std::rand() % (max - min + 1));
				int tmpid = selectedProcessors[pno].getId();
				chrmsm[csno].push_back(tmpid);
				//	cout << "Added " << tmpid << " to Chrmsm " << csno << endl;
				if ((var2 == (num_tasks - 1))
						|| (var2 == ((num_tasks - 1) / 2))) {

					csno++;
				}
			}

		}

	}
//Printing Chromosomes for debugging
	{
		cout << "Generated Chromosomes :" << endl;
		for (unsigned int var = 0; var < chrmsm.size(); var++) {
			for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++) {
				cout << chrmsm[var].at(var2) << ", ";

			}

			if (var % 2 == 0)
				cout << "\t";
			else
				cout << endl;
		}

	}
	//Crossover
	{
		chrmsm[1].swap(chrmsm[3]);

	}

	//Print Crossovered
	//sort(processors.begin(), processors.end(), sortProcsByIdAsc);

	{
		cout << "\nAfter CrossOver\n" << endl;
		for (unsigned int var = 0; var < chrmsm.size(); var++) {
			for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++) {
				cout << chrmsm[var].at(var2) << ", ";
				int tti = chrmsm[var].at(var2);
				if (var < 2) {
					prf1 += processors[tti].getSpeed();
				} else {
					prf2 += processors[tti].getSpeed();

				}
			}

			if (var % 2 == 0)
				cout << "\t";
			else
				cout << endl;
		}

	}
	cout << "\nPrf of Chromosomes : 1st [" << prf1 << "] & 2nd[" << prf2 << "] "
			<< endl;
	//calculate Performance of Chromosomes

	//Schedule Without Duplication
	{
		//long Lastst = 0, Lastet = 0;
		if (prf1 > prf2) {
			for (int var = 0; var < 2; var++) {
				//cout << "1FOund ID" << endl;
				int TaskCounter = var * chrmsm[var].size();

				for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++) {
					for (unsigned int var3 = 0; var3 < processors.size();
							var3++) {
						if (chrmsm[var].at(var2) == processors[var3].identity) {
							processors[var3].Que.push_back(TaskCounter);

							//	break;
						}/* else {

						 //processors[var3].Que.push_back(-999);

						 }*/
					}
					TaskCounter++;
				}
			}
		} else {
			for (unsigned int var = 2; var < chrmsm.size(); var++) {
				int TaskCounter = (var - 2) * chrmsm[var].size();

				//cout << "2 FOund ID" << endl;
				for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++) {
					//cout << "23 FOund ID" << endl;
					for (unsigned int var3 = 0; var3 < processors.size();
							var3++) {
						//cout << "234 FOund ID" << endl;

						if (chrmsm[var].at(var2) == processors[var3].identity) {
							//cout << "2345 FOund ID  "<<processors[var3].identity <<" to "<< processors[var3].Que.size()<<endl;
							processors[var3].Que.push_back(TaskCounter);
							//	break;
						} /*else {

						 //	processors[var3].Que.push_back(-999);

						 }*/

					}
					TaskCounter++;

				}
			}

		}
	}

	{
		/*
		 {
		 for (int i = 0; i < processors.size(); i++) {

		 cout << "Proc " << processors[i].toString() << endl;
		 }

		 }
		 */
	}

	{

		/*// Set Processor's DepQue May be of no use Was Just An Experiment
		 * for (int i = 0; i < processors.size(); i++) {
		 vector<int> QList = processors[i].getQue();
		 for (int j = 0; j < QList.size(); j++) {
		 int get = QList[j];
		 if (get != -999) {
		 vector<int> depList = taskList[get].getDeplist();
		 for (int k = 0; k < depList.size(); k++) {
		 int get1 = depList[k];
		 bool inList = false;
		 //processors.get(i).getDepque().contains(get1)
		 for (int var5 = 0; var5 < processors[i].DepQue.size();
		 var5++) {
		 if (processors[i].DepQue[var5] == get1) {
		 inList = true;
		 }
		 }

		 if (!inList) {
		 processors[i].DepQue.push_back(get1);
		 }
		 }
		 }
		 }
		 sort(processors[i].DepQue.begin(), processors[i].DepQue.end());
		 //  System.out.println("Processor ID " + processors.get(i).getId() + " " + processors.get(i).getDepque());
		 }*/

		long Lastst = 0, Lastet = 0;
		//int LastTaskID = 0;
		//bool TimeSet = false;
		//set Times
		//for (int i = 0; i < 2; i++)
		{
			if (prf1 > prf2) {
				for (int var = 0; var < 2; var++) {
					int tc = var * chrmsm[var].size();

					for (unsigned int var2 = 0; var2 < chrmsm[var].size();
							var2++) {
						Lastst = Lastet + 1;
						taskList[tc].setStarttime(Lastst);
						Lastet = Lastst
								+ ((1000
										* ((long) ((taskList[tc].getVal()
												/ processors[chrmsm[var].at(
														var2)].getSpeed())
												* 10000))) / 10000);
						taskList[tc].setEndtime(Lastet);
						taskList[tc].setExectime(
								((1000
										* ((long) ((taskList[tc].getVal()
												/ processors[chrmsm[var].at(
														var2)].getSpeed())
												* 10000))) / 10000));
						//LastTaskID = taskList[tc].getTId();
						taskListNoDup.push_back(taskList[tc]);
						tc++;
					}
				}
			} else {
				for (unsigned int var = 2; var < chrmsm.size(); ++var) {
					int tc = (var - 2) * chrmsm[var].size();
					for (unsigned int var2 = 0; var2 < chrmsm[var].size();
							var2++) {
						Lastst = Lastet + 1;
						taskList[tc].setStarttime(Lastst);
						Lastet = Lastst
								+ ((1000
										* ((long) ((taskList[tc].getVal()
												/ processors[chrmsm[var].at(
														var2)].getSpeed())
												* 10000))) / 10000);
						taskList[tc].setEndtime(Lastet);
						taskList[tc].setExectime(
								((1000
										* ((long) ((taskList[tc].getVal()
												/ processors[chrmsm[var].at(
														var2)].getSpeed())
												* 10000))) / 10000));
						//LastTaskID = taskList[tc].getTId();
						taskListNoDup.push_back(taskList[tc]);
						tc++;
					}

				}

			}
		}

		/*while (!TimeSet) {
		 for (int i = 0; i < processors.size(); i++) {
		 vector<int> t = processors[i].getQue();
		 for (int j = 0; j < t.size(); j++) {
		 int get = t[j];
		 {
		 if (get != -999) {
		 if (taskList[get].getTId() > (LastTaskID + 1)) {
		 break;
		 } else if (taskList[get].getEndtime() != 0
		 || taskList[get].getStarttime() != 0) {
		 continue;
		 } else if (taskList[get].getTId() == LastTaskID
		 || taskList[get].getTId()
		 == (LastTaskID + 1)) {
		 Lastst = Lastet + 1;
		 taskList[get].setStarttime(Lastst);
		 //		                            System.out.println("Value of Task " + get.getValue() + " Processor Performance " + processors.get(i).getPrf()
		 //	                                    + " Time Taken " + get.getValue() / processors.get(i).getPrf());
		 //TimeUnit.SECONDS.toMillis
		 //TimeUnit.SECONDS.toMillis
		 Lastet =
		 Lastst
		 + ((1000
		 * ((long) ((taskList[get].getVal()
		 / processors[i].getSpeed())
		 * 10000)))
		 / 10000);
		 taskList[get].setEndtime(Lastet);
		 taskList[get].setExectime(
		 ((1000
		 * ((long) ((taskList[get].getVal()
		 / processors[i].getSpeed())
		 * 10000))) / 10000));
		 LastTaskID = taskList[get].getTId();
		 taskListNoDup.push_back(taskList[get]);
		 cout << "pushed Task " << taskList[get].getTId()
		 << endl;
		 if (LastTaskID == num_tasks - 1) {
		 TimeSet = true;
		 }

		 }
		 }
		 }
		 }
		 }
		 }*/

	}

	{
		/*	for (int i1 = 0; i1 < taskListNoDup.size(); i1++) {
		 cout << taskListNoDup[i1].toString();
		 }
		 */
	}

	// setting PreTasks
	{
		setPreTasks();
	}

	/*cout << "After PreTasks" << endl;
	 {
	 for (int i1 = 0; i1 < taskListNoDup.size(); i1++) {
	 cout << taskList[i1].toString();
	 }
	 }
	 */
	// set Timings After PreTasks
	{

		long Lastst = 0, Lastet = 0;
		//int LastTaskID = 0;
		//	bool TimeSet = false;
		//	int tc = 0;
		//for (int i = 0; i < 2; i++)
		{
			if (prf1 > prf2) {
				for (int var = 0; var < 2; var++) {
					int tc = var * chrmsm[var].size();
					for (unsigned int var2 = 0; var2 < chrmsm[var].size();
							var2++) {
						vector<int> depl, ptl;
						depl = taskList[tc].getDeplist();
						ptl = taskList[tc].getPretask();

						int lastDepTaskID = -99;
						int lastPreTaskID = -99;
						if (depl.size() > 0) {
							lastDepTaskID = depl.at(depl.size() - 1);
						}

						if (ptl.size() > 0) {

							lastPreTaskID = ptl.at(ptl.size() - 1);
						}

						long lastETDepTask = 0, lastETPreTask = 0;
						if (lastDepTaskID != -99) {

							lastETDepTask =
									taskList[lastDepTaskID].getEndtime();
						}
						if (lastPreTaskID != -99) {
							lastETPreTask =
									taskList[lastPreTaskID].getEndtime();

						}
						/*cout << "LastDepT " << lastDepTaskID << " LastPT "
						 << lastPreTaskID << endl;
						 cout << "max between " << lastETDepTask << " & "
						 << lastETPreTask << " "
						 << std::max(lastETDepTask, lastETPreTask)
						 << endl;
						 */
						Lastst = std::max(lastETDepTask, lastETPreTask) + 1;
						taskList[tc].setStarttime(Lastst);
						Lastet = Lastst + taskList[tc].getExectime();
						taskList[tc].setEndtime(Lastet);
						//	LastTaskID = taskList[tc].getTId();
						taskListAfterPretask.push_back(taskList[tc]);
						int tpid = chrmsm[var].at(var2);
						quesAfterDup[tpid].push_back(taskList[tc]);
						sort(quesAfterDup[tpid].begin(),
								quesAfterDup[tpid].end(), sortTasksByIDAsc);

						tc++;
					}
				}
			} else {
				for (unsigned int var = 2; var < chrmsm.size(); ++var) {
					int tc = (var - 2) * chrmsm[var].size();
					for (unsigned int var2 = 0; var2 < chrmsm[var].size();
							var2++) {
						vector<int> depl, ptl;
						depl = taskList[tc].getDeplist();
						ptl = taskList[tc].getPretask();

						int lastDepTaskID = -99;
						int lastPreTaskID = -99;
						if (depl.size() > 0) {
							lastDepTaskID = depl.at(depl.size() - 1);
						}

						if (ptl.size() > 0) {

							lastPreTaskID = ptl.at(ptl.size() - 1);
						}

						long lastETDepTask = 0, lastETPreTask = 0;
						if (lastDepTaskID != -99) {

							lastETDepTask =
									taskList[lastDepTaskID].getEndtime();
						}
						if (lastPreTaskID != -99) {
							lastETPreTask =
									taskList[lastPreTaskID].getEndtime();

						}
						/*cout << "LastDepT " << lastDepTaskID << " LastPT "
						 << lastPreTaskID << endl;

						 cout << "max between " << lastETDepTask << " & "
						 << lastETPreTask << " "
						 << std::max(lastETDepTask, lastETPreTask)
						 << endl;
						 */Lastst = std::max(lastETDepTask, lastETPreTask) + 1;
						taskList[tc].setStarttime(Lastst);
						Lastet = Lastst + taskList[tc].getExectime();
						taskList[tc].setEndtime(Lastet);
						//	LastTaskID = taskList[tc].getTId();
						taskListAfterPretask.push_back(taskList[tc]);
						int tpid = chrmsm[var].at(var2);
						quesAfterDup[tpid].push_back(taskList[tc]);
						sort(quesAfterDup[tpid].begin(),
								quesAfterDup[tpid].end(), sortTasksByIDAsc);

						tc++;
					}

				}

			}
		}

	}

	{

		cout << "\nAfter PreTasks Timings" << endl;
		{
			for (unsigned int i1 = 0; i1 < taskList.size(); i1++) {
				cout << taskList[i1].toString();
				if (maxTimeBefDup < taskList[i1].getEndtime()) {
					maxTimeBefDup = taskList[i1].getEndtime();

				}
			}
		}

	}

//Task Duplication
	/*
	 * Change TaskList to QueAfterDup
	 * Add getTask from Processor
	 * Add updateTime
	 * */
	{
		//long Lastst = 0, Lastet = 0;
		{
			{
				for (unsigned int var = 0; var < quesAfterDup.size(); var++) {
					//sort(quesAfterDup[var].begin(), quesAfterDup[var].end(),
						//	sortTasksByIDAsc);
					for (unsigned int var2 = 0; var2 < quesAfterDup[var].size();
							var2++) {
						vector<int> depl, ptl;
						depl = quesAfterDup[var].at(var2).getDeplist();
						ptl = quesAfterDup[var].at(var2).getPretask();

						int lastDepTaskID = -99;
						int lastPreTaskID = -99;
						if (depl.size() > 0) {
							lastDepTaskID = depl.at(depl.size() - 1);
						}

						if (ptl.size() > 0) {

							lastPreTaskID = ptl.at(ptl.size() - 1);
							//quesAfterDup[chrmsm[var].at(var2)]
						}

						long lastETDepTask = 0, lastETPreTask = 0;
						if (lastDepTaskID != -99) {

							lastETDepTask =
									getTaskFromProcQueAfterDupMinEndTime(
											lastDepTaskID,
											taskList[lastDepTaskID].getEndtime()).getEndtime();
						}
						if (lastPreTaskID != -99) {

							for (unsigned int var3 = 0;
									var3 < quesAfterDup[var].size(); var3++) {
								if (quesAfterDup[var].at(var3).getTId()
										== lastPreTaskID) {

									lastETPreTask =
											quesAfterDup[var].at(var3).getEndtime();
									break;
								}

							}

						}

						if (lastETDepTask > lastETPreTask) {
							//cout << "Dup Tasks Dep Task > ET PTask" << endl;
							for (unsigned int var5 = 0; var5 < depl.size();
									var5++) {
								Task tempdTask =
										getTaskFromProcQueAfterDupMinEndTime(
												depl[var5],
												taskList[depl[var5]].getEndtime());
								if (tempdTask.getTId() != depl[var5]) {
									continue;
								}
								long tempdET = tempdTask.getEndtime();
								//	taskList[depl[var5]].getEndtime();
								if (tempdET > lastETPreTask) {
									/*	cout << "Dup Tasks Dep Task :" << var5
									 << ": > ET PTask" << endl;
									 */
									long tempExcT = tempdTask.getExectime();
									long tempExcOnCP =
											((1000
													* ((long) ((tempdTask.getVal()
															/ processors[var].getSpeed())
															* 10000))) / 10000);
									if (tempExcOnCP < tempExcT) {
										/*									cout << "Dup Tasks Dep Task :"
										 << depl[var5]
										 << ": > ET PTask Exec Time ON CP is less"
										 << endl;
										 */
										if ((lastETPreTask + 1 + tempExcOnCP)
												< tempdET) {
											/*	cout << "Dup Tasks Dep Task :"
											 << depl[var5]
											 << ": > ET PTask Exec Time ON CP is less Also finish first here"
											 << endl;
											 */
											//cout << "1" << endl;
											quesAfterDup[var].push_back(
													tempdTask);
											//cout << "2" << endl;

											sort(quesAfterDup[var].begin(),
													quesAfterDup[var].end(),
													sortTasksByIDAsc);
										//	cout << "3" << endl;

											setPreTasksForQuesAfterDup();
										//	cout << "4" << endl;

											cout << "Duplicated task "
													<< depl[var5] << " to "
													<< var << endl;
											//	printQueDup();

											updateTimingsinQueWithDup();
										}
									}
								}
							}

						}

						if (maxTimeAftDup
								< quesAfterDup[var].at(var2).getEndtime()) {
							maxTimeAftDup =
									quesAfterDup[var].at(var2).getEndtime();
						}

//						tc++;
					}
				}
			}

		}
	}

	cout << "Printing New Tasks in Ques" << endl;
	{
		printQueDup();

	}

	end = clock();
	time_spent = (double) (end - begin) / CLOCKS_PER_SEC;

	{
		cout << "Generated Chromosomes :" << endl;
		for (int var = 0; var < chrmsm.size(); var++) {
			for (int var2 = 0; var2 < chrmsm[var].size(); var2++) {
				cout << chrmsm[var].at(var2) << ", ";

			}

			if (var % 2 == 0)
				cout << "\t";
			else
				cout << endl;
		}

	}

	{
		cout << "Selected Chromosome :" << endl;
		if (prf1 > prf2) {
			for (int var = 0; var < 2; var++) {
				for (int var2 = 0; var2 < chrmsm[var].size(); var2++) {
					cout << chrmsm[var].at(var2) << ", ";

				}

				if (var % 2 == 0)
					cout << "\t";
				else
					cout << endl;
			}
		} else {

			for (int var = 2; var < chrmsm.size(); var++) {
				for (int var2 = 0; var2 < chrmsm[var].size(); var2++) {
					cout << chrmsm[var].at(var2) << ", ";

				}

				if (var % 2 == 0)
					cout << "\t";
				else
					cout << endl;
			}

		}
	}

	cout << "max End Time before task Dup :" << maxTimeBefDup << endl;
	cout << "max End Time after task Dup :" << maxTimeAftDup << endl;

	cout << "Time Spent : " << time_spent << endl;

	return 0;
}
